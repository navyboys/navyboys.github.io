---
layout: post
title: "Regex with Javascript"
date: 2016-10-10 20:59
comments: true
categories: [regex, javascript, note]
keywords: regex development javascript
description: Notes of Eloquent Javascript - Regular Expressions
---

Regular expressions are a sharp tool with an awkward handle. They simplify some tasks tremendously but can quickly become unmanageable when applied to complex problems. Part of knowing how to use them is resisting the urge to try to shoehorn things that they cannot sanely express into them.

This is the notes taken for [Eloquent Javascript](http://eloquentjavascript.net/)'s [Regular Expressions](http://eloquentjavascript.net/09_regexp.html) chapter, concentrated on the programming interface JavaScript provides for Regex.

## Creating a regular expression

In JavaScript, a regular expression is a type of object. It can either be constructed with the `RegExp` constructor or written as a literal value by enclosing the pattern in forward slash (`/`) characters.

``` javascript
var re1 = new RegExp("abc");
var re2 = /abc/;
```

## Methods for Regular Expression Object

A regular expression has a method `test` to test whether a given string matches it. It also has an `exec` method that, when a match is found, returns an array containing all matched groups. Such an array has an `index` property that indicates where the match started.

#### `test`

``` javascript
console.log(/abc/.test("abcde")); // → true
console.log(/abc/.test("abxde")); // → false
```

#### `exec`

``` javascript
var match = /\d+/.exec("one two 100");
console.log(match);        // → ["100"]
console.log(match.index);  // → 8
```

When the regular expression contains subexpressions grouped with parentheses, the text that matched those groups will also show up in the array. The whole match is always the first element. The next element is the part matched by the first group (the one whose opening parenthesis comes first in the expression), then the second group, and so on.

``` javascript
console.log(/bad(ly)?/.exec("bad")); // → ["bad", undefined]
console.log(/(\d)+/.exec("123"));    // → ["123", "3"]
```

## Methods for String

Strings have a `match` method to match them against a regular expression and a `search` method to search for one, returning only the starting position of the match. Their `replace` method can replace matches of a pattern with a replacement string. Alternatively, you can pass a function to replace, which will be used to build up a replacement string based on the match text and matched groups.

Regular expressions can have **options**, which are written after the closing slash. The `i` option makes the match _case insensitive_, while the `g` option makes the expression _global_, which, among other things, causes the replace method to replace all instances instead of just the first.

#### `match`

``` javascript
console.log("one two 100".match(/\d+/)); // → ["100"]
console.log("bad".match(/bad(ly)?/));    // → ["bad", undefined]
```

#### `search`

``` javascript
console.log("  word".search(/\S/)); // → 2
console.log("      ".search(/\S/)); // → -1
```

#### `replace`

``` javascript
console.log("Borobudur".replace(/[ou]/, "a"));  // → Barobudur
console.log("Borobudur".replace(/[ou]/g, "a")); // → Barabadar
```

The real power of using regular expressions with replace comes from the fact that we can **refer back to matched groups** in the replacement string.

``` javascript
console.log(
  "Hopper, Grace\nMcCarthy, John\nRitchie, Dennis"
    .replace(/([\w ]+), ([\w ]+)/g, "$2 $1"));

// → Grace Hopper
//   John McCarthy
//   Dennis Ritchie
```

`$1` is replaced by the text that matched against the first group, `$2` by the second, and so on, up to `$9`. The whole match can be referred to with `$&`.

It is also possible to **pass a function**, rather than a string, as the second argument to replace.

``` javascript
var s = "the cia and fbi";
console.log(s.replace(/\b(fbi|cia)\b/g, function(str) {
  return str.toUpperCase();
}));

// → the CIA and FBI
```

## Dynamically creating RegExp objects

You can use the `RegExp` constructor to create regular expression dynamically.

``` javascript
var name = "harry";
var text = "Harry is a suspicious character.";
var regexp = new RegExp("\\b(" + name + ")\\b", "gi");
console.log(text.replace(regexp, "_$1_"));

// → _harry_ is a suspicious character.
```

We can add backslashes before any character that we don’t trust. Adding backslashes before alphabetic characters is a bad idea because things like `\b` and `\n` have a special meaning. But escaping everything that’s not alphanumeric or whitespace is safe.

``` javascript
var name = "dea+hl[]rd";
var text = "This dea+hl[]rd guy is super annoying.";
var escaped = name.replace(/[^\w\s]/g, "\\$&");
var regexp = new RegExp("\\b(" + escaped + ")\\b", "gi");
console.log(text.replace(regexp, "_$1_"));

// → This _dea+hl[]rd_ guy is super annoying.
```

## The lastIndex property

The `exec` method similarly does not provide a convenient way to start searching from a given position in the string. But it does provide an inconvenient way.

Regular expression objects have properties. One such property is `source`, which contains the string that expression was created from. Another property is `lastIndex`, which controls, in some limited circumstances, where the next match will start.

Those circumstances are that the regular expression must have the **global** (g) option enabled, and the match must happen through the **exec** method.

``` javascript
var pattern = /y/g;
pattern.lastIndex = 3;
var match = pattern.exec("xyzzy");
console.log(match.index);        // → 4
console.log(pattern.lastIndex);  // → 5
```

If the match was successful, the call to exec automatically updates the lastIndex property to point after the match. If no match was found, lastIndex is set back to zero, which is also the value it has in a newly constructed regular expression object.

When using a global regular expression value for multiple exec calls, these automatic updates to the lastIndex property can cause problems. Your regular expression might be accidentally starting at an index that was left over from a previous call.

``` javascript
var digit = /\d/g;
console.log(digit.exec("here it is: 1")); // → ["1"]
console.log(digit.exec("and now: 1"));    // → null
```

Another interesting effect of the **global** option is that it changes the way the `match` method on strings works. When called with a **global** expression, instead of returning an array similar to that returned by `exec`, `match` will find all matches of the pattern in the string and return an array containing the matched strings.

``` javascript
console.log("Banana".match(/an/g)); // → ["an", "an"]
```

So be cautious with global regular expressions. The cases where they are necessary—calls to **replace** and places where you want to explicitly use **lastIndex**—are typically the only places where you want to use them.

## Looping over matches

A common pattern is to scan through all occurrences of a pattern in a string, in a way that gives us access to the match object in the loop body, by using `lastIndex` and `exec`.

``` javascript
var input = "A string with 3 numbers in it... 42 and 88.";
var number = /\b(\d+)\b/g;
var match;
while (match = number.exec(input))
  console.log("Found", match[1], "at", match.index);

// → Found 3 at 14
//   Found 42 at 33
//   Found 88 at 40
```

## Parsing an INI file

Imagine we are writing a program to automatically harvest information about our enemies from the Internet.

- INI file

```
searchengine=http://www.google.com/search?q=$1
spitefulness=9.7

; comments are preceded by a semicolon...
; each section concerns an individual enemy
[larry]
fullname=Larry Doe
type=kindergarten bully
website=http://www.geocities.com/CapeCanaveral/11451

[gargamel]
fullname=Gargamel
type=evil sorcerer
outputdir=/home/marijn/enemies/gargamel
```

- Parsing program in Javascript

``` javascript
function parseINI(string) {
  // Start with an object to hold the top-level fields
  var currentSection = {name: null, fields: []};
  var categories = [currentSection];

  string.split(/\r?\n/).forEach(function(line) {
    var match;
    if (/^\s*(;.*)?$/.test(line)) {
      return;
    } else if (match = line.match(/^\[(.*)\]$/)) {
      currentSection = {name: match[1], fields: []};
      categories.push(currentSection);
    } else if (match = line.match(/^(\w+)=(.*)$/)) {
      currentSection.fields.push({name: match[1],
                                  value: match[2]});
    } else {
      throw new Error("Line '" + line + "' is invalid.");
    }
  });

  return categories;
}
```
